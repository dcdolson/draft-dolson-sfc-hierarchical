<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-ietf-sfc-hierarchical-08"
     ipr="trust200902">
  <!-- ***** FRONT MATTER ***** -->

  <front>
    <title abbrev="hSFC">Hierarchical Service Function Chaining (hSFC)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <author fullname="David Dolson" initials="D." surname="Dolson">
      <organization></organization>

      <address>
        <postal>
          <street></street>

          <!-- Reorder these if your country does things differently -->

          <city>Waterloo</city>

          <region>ON</region>

          <code></code>

          <country>Canada</country>
        </postal>

        <phone></phone>

        <email>ddolson@acm.org</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Shunsuke Homma" initials="S." surname="Homma">
      <organization abbrev="NTT">NTT, Corp.</organization>

      <address>
        <postal>
          <street>3-9-11, Midori-cho</street>

          <city>Musashino-shi</city>

          <region>Tokyo</region>

          <code>180-8585</code>

          <country>Japan</country>
        </postal>

        <email>homma.shunsuke@lab.ntt.co.jp</email>
      </address>
    </author>

    <author fullname="Diego R. Lopez" initials="D. R." surname="Lopez">
      <organization>Telefonica I+D</organization>

      <address>
        <postal>
          <street>Don Ramon de la Cruz, 82</street>

          <city>Madrid</city>

          <region></region>

          <code>28006</code>

          <country>Spain</country>
        </postal>

        <phone>+34 913 129 041</phone>

        <email>diego.r.lopez@telefonica.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <date year="2018" />

    <!-- Meta-data Declarations -->

    <area>Routing Area</area>

    <workgroup>Service Function Chaining</workgroup>

    <keyword>sfc</keyword>

    <keyword>hierarchical</keyword>

    <abstract>
      <t>Hierarchical Service Function Chaining (hSFC) is a network
      architecture allowing an organization to decompose a large-scale network
      into multiple domains of administration.</t>

      <t>The goals of hSFC are to make a large-scale network easier to reason
      about, simpler to control and to support independent functional groups
      within large network operators.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Service Function Chaining (SFC) is a technique for prescribing
      differentiated traffic forwarding policies within an SFC-enabled domain.
      The SFC architecture is described in detail in <xref
      target="RFC7665"></xref>, and is not repeated here.</t>

      <t>This document focuses on the difficult problem of implementing SFC
      across a large, geographically dispersed network, potentially comprised
      of millions of hosts and thousands of network forwarding elements, and
      which may involve multiple operational teams (with varying functional
      responsibilities). We recognize that some stateful Service Functions
      (SFs) require bidirectional traffic for transport-layer sessions (e.g.,
      NATs, firewalls). We assume that some Service Function Paths (SFPs) need
      to be selected on the basis of application-specific data visible to the
      network, with transport-layer coordinate (typically, the 5-tuple (source
      IP address, source port number, destination IP address, destination port
      number, transport protocol)) stickiness to specific stateful SF
      instances.</t>

      <t>Difficult problems are often made easier by decomposing them in a
      hierarchical (nested) manner. So instead of considering a single SFC
      Control Plane (<xref target="I-D.ietf-sfc-control-plane"></xref>) that
      can manage (create, withdraw, supervise, etc.) complete SFPs from one
      end of the network to the other, we decompose the network into smaller
      domains operated by as many SFC control plane components (under the same
      administrative entity). Coordination between such components is further
      discussed in the document.</t>

      <t>Each sub-domain may support a subset of the network applications or a
      subset of the users. Decomposing a network into multiple SFC-enabled
      domains should permit end-to-end visibility of SFs and SFPs. Also,
      decomposing should be done with care to ease monitoring and
      troubleshooting of the network and services as a whole. The criteria for
      decomposing a domain into multiple SFC-enabled sub-domains are beyond
      the scope of this document. These criteria are deployment-specific.</t>

      <t>An example of simplifying a network by using multiple SFC-enabled
      domains is further discussed in <xref
      target="I-D.ietf-sfc-dc-use-cases"></xref>.</t>

      <t>We assume the SFC-aware nodes use <xref target="RFC8300">NSH</xref>
      or a similar labeling mechanism. Sample examples are described in <xref
      target="app1"></xref>.</t>

      <t>The "domains" discussed in this document are assumed to be under the
      control of a single organization (an operator, typically), such that
      there is a strong trust relationship between the domains. The intention
      of creating multiple domains is to improve the ability to operate a
      network. It is outside of the scope of the document to consider domains
      operated by different organizations or to dwell on inter-operator
      considerations.</t>
    </section>

    <section title="Hierarchical Service Function Chaining (hSFC)">
      <t>A hierarchy has multiple levels: the top-most level encompasses the
      entire network domain to be managed, and lower levels encompass portions
      of the network. These levels are discussed in the following
      sub-sections.</t>

      <section anchor="hl" title="Top Level">
        <t>Considering the example depicted in <xref
        target="fig_hierarchical_top"></xref>, a top-level network domain
        includes SFC data plane components distributed over a wide area,
        including: <list style="symbols">
            <t>Classifiers (CFs),</t>

            <t>Service Function Forwarders (SFFs) and</t>

            <t>Sub-domains.</t>
          </list></t>

        <figure anchor="fig_hierarchical_top"
                title="Network-wide view of top level of hierarchy">
          <artwork><![CDATA[
                 +------------+
                 |Sub-domain#1|
                 |  in DC1    | 
                 +----+-------+
                      |
               .---- SFF1 ------.   +--+
       +--+   /     /  |         \--|CF|
   --->|CF|--/---->'   |          \ +--+
       +--+ /  SC#1    |           \
            |          |            |
            |          V    .------>|--->
            |         /    /        |
            \         |   /        /
       +--+  \        |  /        /  +--+
       |CF|---\       | /        /---|CF|
       +--+    '---- SFF2 ------'    +--+
                      |
                 +----+-------+
                 |Sub-domain#2|
                 |   in DC2   |
                 +------------+

   Legend:
      SC#1: Service Chain 1
        DC: Data Center
         ]]></artwork>

          <postamble>One path is shown from edge classifier to SFF1 to
          Sub-domain#1 (residing in data-center1) to SFF1 to SFF2 (residing in
          data-center 2) to Sub-domain#2 to SFF2 to network
          egress.</postamble>
        </figure>

        <t>For the sake of clarity, components of the underlay network are not
        shown; an underlay network is assumed to provide connectivity between
        SFC data plane components.</t>

        <t>Top-level SFPs carry packets from classifiers through a set of SFFs
        and sub-domains, with the operations within sub-domains being opaque
        to the higher levels.</t>

        <t>We expect the system to include a top-level control plane having
        responsibility for configuring forwarding policies and traffic
        classification rules (see for example, <xref
        target="I-D.ietf-sfc-control-plane"></xref>).</t>

        <t>The top-level Service Chaining control plane manages end-to-end
        service chains and associated service function paths from network edge
        points to sub-domains and configures top-level classifiers at a coarse
        level (e.g., based on source or destination host) to forward traffic
        along paths that will transit across appropriate sub-domains.</t>

        <t><xref target="fig_hierarchical_top"></xref> shows one possible
        service chain passing from edge, through two sub-domains, to network
        egress. The top-level control plane does not configure traffic
        classification rules or forwarding policies within the
        sub-domains.</t>

        <t>At this network-wide level, the number of SFPs required is a linear
        function of the number of ways in which a packet is required to
        traverse different sub-domains and egress the network. Note that the
        various paths which may be followed within a sub-domain are not
        represented by distinct network-wide SFPs; specific policies at the
        ingress nodes of each sub-domain bind flows to sub-domain paths.</t>

        <t>Packets are classified at the edge of the network to select the
        paths by which sub-domains are to be traversed. At the ingress of each
        sub-domain, packets are reclassified to paths directing them to the
        required SFs of the sub-domain. At the egress of each sub-domain,
        packets are returned to the top-level paths. Contrast this with an
        approach requiring the top-level classifier to select paths to specify
        all of the SFs in each sub-domain.</t>

        <t>It should be assumed that some SFs require bidirectional symmetry
        of paths (see more in <xref target="section_classifier"></xref>).
        Therefore the classifiers at the top level must be configured with
        policies ensuring outgoing packets take the reverse path of incoming
        packets through sub-domains.</t>
      </section>

      <section anchor="ll" title="Lower Levels">
        <t>Each of the sub-domains in <xref
        target="fig_hierarchical_top"></xref> is an SFC-enabled domain.</t>

        <t><xref target="fig_hierarchical_lower"></xref> shows a sub-domain
        interfaced with a higher-level domain by means of an Internal Boundary
        Node (IBN). An IBN acts as an SFC-aware SF in the higher-level domain
        and as a classifier in the lower-level domain. As such, data packets
        entering the sub-domain are already SFC-encapsulated. Also, it is the
        purpose of the IBN to apply classification rules and direct the
        packets to the selected local SFPs terminating at an egress IBN. The
        egress IBN finally restores packets to the original SFC shim and hands
        them off to SFFs.</t>

        <t>Each sub-domain intersects a subset of the total paths that are
        possible in the higher-level domain. An IBN is concerned with
        higher-level paths, but only those traversing its sub-domain.</t>

        <t>Each sub-domain is likely to have a control plane that can operate
        independently of the top-level control plane, managing classification,
        forwarding paths, etc. within the level of the sub-domain, with the
        details being opaque to the upper-level control elements. <xref
        target="ibn"></xref> provides more details about the behavior of an
        IBN.</t>

        <t>The sub-domain control plane configures the classification rules in
        the IBN, where SFC encapsulation of the top-level domain is converted
        to/from SFC encapsulation of the lower-level domain. The sub-domain
        control plane also configures the forwarding rules in the SFFs of the
        sub-domain.</t>

        <figure anchor="fig_hierarchical_lower"
                title="Example of a sub-domain within a higher-level domain">
          <artwork><![CDATA[
  +----+    +-----+  +----------------------+   +-----+
  |    |    | SFF |  |   IBN 1  (in DC 1)   |   | SFF |
  |    |SC#1|     |  |  +----------------+  |   |     |
->|    |===============>|      SFF       |================>
  |    |    +-----+  |  +----------------+  |   +-----+
  | CF |             |   |              ^   |
  |    |             |   v              |   |
  |    |             |+--------------------+|   Top domain
  |    |             ||CF, fwd/rev mapping ||
  |    |    * * * * *||  and "glue"        || * * * * *
  |    |    *        |+--------------------+|         *
  +----+    *        | | |              | | |    Sub  *
            *        +-o-o--------------o-o-+   domain*
            *     SC#2 | |SC#1          ^ ^       #1  *
            *    +-----+ |              | |           *
            *    |       V              | |           *
            *    |     +---+  +------+  | |           *
            *    |     |SFF|->|SF#1.1|--+ |           *
            *    |     +---+  +------+    |           *
            *    V                        |           *
            *  +---+  +------+  +---+  +------+       *
            *  |SFF|->|SF#2.1|->|SFF|->|SF#2.2|       *
            *  +---+  +------+  +---+  +------+       *
            * * * * * * * * * * * * * * * * * * * * * *
Legend:
     *** Sub-domain boundary
     === top-level chain
     --- low-level chain
        ]]></artwork>
        </figure>

        <t>If desired, the pattern can be applied recursively. For example,
        SF#1.1 in <xref target="fig_hierarchical_lower"></xref> could be a
        sub-domain of the sub-domain.</t>
      </section>
    </section>

    <section anchor="ibn" title="Internal Boundary Node (IBN)">
      <t>As mentioned in the previous section, a network element termed
      "Internal Boundary Node" (IBN) is responsible for bridging packets
      between higher and lower layers of SFC-enabled domains. It behaves as an
      SF to the higher level (<xref target="hl"></xref>), and looks like a
      classifier and end-of-chain to the lower level (<xref
      target="ll"></xref>).</t>

      <t>To achieve the benefits of hierarchy, the IBN should be applying more
      granular traffic classification rules at the lower level than the
      traffic passed to it. This means that the number of SFPs within the
      lower level is greater than the number of SFPs arriving to the IBN.</t>

      <t>The IBN is also the termination of lower-level SFPs. This is because
      the packets exiting lower-level SF paths must be returned to the
      higher-level SF paths and forwarded to the next hop in the higher-level
      domain.</t>

      <t>When different metadata schemes are used at different levels, the IBN
      has further responsibilities: when packets enter the sub-domain, the IBN
      translates upper-level metadata into lower-level metadata; and when
      packets leave the sub-domain at the termination of lower-level SFPs, the
      IBN translates lower-level metadata into upper-level metadata.</t>

      <t>Appropriately configuring IBNs is key to ensure the consistency of
      the overall SFC operation within a given domain that enables hSFC.
      Classification rules (or lack thereof) in the IBN classifier can of
      course impact higher levels.</t>

      <section anchor="section_strategies" title="IBN Path Configuration">
        <t>The lower-level domain may be provisioned with valid high-level
        paths or may allow any high-level paths.</t>

        <t>When packets enter the sub-domain, the Service Path Identifier
        (SPI) and Service Index (SI) are re-marked according to the path
        selected by the (sub-domain) classifier.</t>

        <t>At the termination of an SFP in the sub-domain, packets can be
        restored to an original upper-level SFP by implementing one of these
        methods: <list style="numbers">
            <t>Saving SPI and SI in transport-layer flow state (<xref
            target="section_flow_stateful"></xref>).</t>

            <t>Pushing SPI and SI into a metadata header (<xref
            target="enco_meta"></xref>).</t>

            <t>Using unique lower-level paths per upper-level path coordinates
            (<xref target="section_unique_paths"></xref>).</t>

            <t>Nesting NSH headers, encapsulating the higher-level NSH headers
            within the lower-level NSH headers (<xref
            target="nest"></xref>).</t>

            <t>Saving upper-level by a flow identifier (ID) and placing an
            hSFC flow ID into a metadata header (<xref
            target="hybrid"></xref>).</t>
          </list></t>

        <section anchor="section_flow_stateful" title="Flow-Stateful IBN">
          <t>An IBN can be flow-aware, returning packets to the correct
          higher-level SFP on the basis, for example, of the transport-layer
          coordinates (typically, a 5-tuple) of packets exiting the
          lower-level SFPs.</t>

          <t>When packets are received by the IBN on a higher-level path, the
          classifier parses encapsulated packets for IP and transport-layer
          (TCP, UDP, etc.) coordinates. State is created, indexed by some or
          all transport-coordinates ({source-IP, destination-IP, source-port,
          destination-port and transport protocol}, typically). The state
          contains at minimum the critical fields of the encapsulating SFC
          header (SPI, SI, MD Type, flags); additional information carried in
          the packet (metadata, TTL) may also be extracted and saved as state.
          Note, that the some fields of a packet may be altered by an SF of
          the sub-domain (e.g., source IP address).</t>

          <t>Note that this state is only accessed by the classifier and
          terminator functions of the sub-domain. Neither the SFFs nor SFs
          have knowledge of this state; in fact they may be agnostic about
          being in a sub-domain.</t>

          <t>One approach is to ensure that packets are terminated at the same
          IBN at the end of the chain that classified the packet at the start
          of the chain. If the packet is returned to a different egress IBN,
          state must be synchronized between the IBNs.</t>

          <t>When a packet returns to the IBN at the end of a chain (which is
          the SFP terminating node of the lower-level chain), the SFC header
          is removed, the packet is parsed for flow-identifying information,
          and state is retrieved from them. The state contains the information
          required to forward the packet within the higher-level service
          chain.</t>

          <t>State cannot be created by packets arriving from the lower-level
          chain; when state cannot be found for such packets, they must be
          dropped. <!-- REVISIT: Med wanted:
          must be dropped by default. An IBN may be configured to forward
          packets that do not match an active state (e.g., ICMP error messages
          generated by a SF).
   --></t>

          <t>This stateful approach is limited to use with SFs that retain the
          transport coordinates of the packet. This approach cannot be used
          with SFs that modify those coordinates (e.g., NATs) or otherwise
          create packets for new coordinates other than those received (e.g.,
          as an HTTP cache might do to retrieve content on behalf of the
          original flow). In both cases, the fundamental problem is the
          inability to forward packets when state cannot be found for the
          packet transport-layer coordinates.</t>

          <t>In the stateful approach, there are issues caused by having
          state, such as how long the state should be maintained, as well as
          whether the state needs to be replicated to other devices to create
          a highly available network.</t>

          <t>It is valid to consider the state to be disposable after failure,
          since it can be re-created by each new packet arriving from the
          higher-level domain. For example, if an IBN loses all flow state,
          the state is re-created by an end-point retransmitting a TCP
          packet.</t>

          <t>If an SFC domain handles multiple network regions (e.g., multiple
          private networks), the coordinates may be augmented with additional
          parameters, perhaps using some metadata to identify the network
          region.</t>

          <t>In this stateful approach, it is not necessary for the
          sub-domain's control plane to modify paths when higher-level paths
          are changed. The complexity of the higher-level domain does not
          cause complexity in the lower-level domain.</t>

          <t>Since it doesn't depend on NSH in the lower domain, this
          flow-stateful approach can be applied to translation methods of
          converting NSH to other forwarding techniques (refer to <xref
          target="section_other_forwarding"></xref>).</t>
        </section>

        <section anchor="enco_meta"
                 title="Encoding Upper-Level Paths in Metadata">
          <t>An IBN can push the upper-level SPI and SI (or encoding thereof)
          into a metadata field of the lower-level encapsulation (e.g.,
          placing upper-level path information into a metadata field of NSH).
          When packets exit the lower-level path, the upper-level SPI and SI
          can be restored from the metadata retrieved from the packet.</t>

          <t>This approach requires the SFs in the path to be capable of
          forwarding the metadata and appropriately attaching metadata to any
          packets injected for a flow.</t>

          <t>Using new metadata header may inflate packet size when
          variable-length metadata (NSH MD Type 0x2) is used.</t>

          <t>It is conceivable that the MD Type 0x1 Fixed-Length Context
          Header field of NSH are not all relevant to the lower-level domain.
          In this case, 32 bits of the Fixed Length Context Header could be
          repurposed within the lower-level domain, and restored when
          leaving.</t>

          <t>If flags or TTL (see <xref target="section_ttl"></xref>) from the
          original header also need to be saved, more metadata space will be
          consumed.</t>

          <t>In this metadata approach, it is not necessary for the
          sub-domain's control element to modify paths when higher-level paths
          are changed. The complexity of the higher-level domain does not
          increase complexity in the lower-level domain.</t>
        </section>

        <section anchor="section_unique_paths"
                 title="Using Unique Paths per Upper-Level Path">
          <t>This approach assumes that paths within the sub-domain are
          constrained so that a SPI (of the sub-domain) unambiguously
          indicates the egress SPI and SI (of the upper domain). This allows
          the original path information to be restored at sub-domain egress
          from a look-up table using the sub-domain SPI.</t>

          <t>Whenever the upper-level domain provisions a path via the
          lower-level domain, the lower-level domain control plane must
          provision corresponding paths to traverse the lower-level
          domain.</t>

          <t>A down-side of this approach is that the number of paths in the
          lower-level domain is multiplied by the number of paths in the
          higher-level domain that traverse the lower-level domain. I.e., a
          sub-path must be created for each combination of upper SPI/SI and
          lower chain. The number of paths required for lower-level domains
          will increase exponentially as hierarchy becomes deep.</t>

          <t>A further down-side of this approach is that it requires upper
          and lower levels to utilize the same metadata configuration.</t>

          <t>Furthermore, this approach does not allow any information to be
          stashed away in state or embedded in metadata. E.g., the TTL
          modifications by the lower level cannot be hidden from the upper
          level.</t>
        </section>

        <section anchor="nest"
                 title="Nesting Upper-Level NSH within Lower-Level NSH">
          <t>When packets arrive at an IBN in the top-level domain, the
          classifier in the IBN determines the path for the lower-level domain
          and pushes the new NSH header in front of the original NSH
          header.</t>

          <t>As shown in <xref target="fig_NSH_in_NSH"></xref> the Lower-NSH
          header used to forward packets in the lower-level domain precedes
          the Upper-NSH header from the top-level domain.</t>

          <figure anchor="fig_NSH_in_NSH"
                  title="Encapsulation of NSH within NSH">
            <artwork align="center"><![CDATA[
+---------------------------------+
|  Outer-transport Encapsulation  |
+---------------------------------+
|        Lower-NSH Header         |
+---------------------------------+
|        Upper-NSH Header         |
+---------------------------------+
|          Original Packet        |
+---------------------------------+
            ]]></artwork>
          </figure>

          <t>The traffic with the above stack of two NSH headers is to be
          forwarded according to the Lower-NSH header in the lower-level SFC
          domain. The Upper-NSH header is preserved in the packets but not
          used for forwarding. At the last SFF of the chain of the lower-level
          domain (which resides in the IBN), the Lower-NSH header is removed
          from the packet, and then the packet is forwarded by the IBN to an
          SFF of the upper-level domain. The packet will be forwarded in the
          top-level domain according to the Upper-NSH header.</t>

          <t>With such encapsulation, Upper-NSH information is carried along
          the extent of the lower-level chain without modification.</t>

          <t>A benefit of this approach is that it does not require state in
          the IBN or configuration to encode fields in meta-data. All header
          fields, including flags and TTL are easily restored when the chains
          of the sub-domain terminate.</t>

          <t>However, the down-side is it does require SFC-aware SFs in the
          lower-level domain to be able to parse multiple NSH layers. If an
          SFC-aware SF injects packets, it must also be able to deal with
          adding appropriate multiple layers of headers to injected
          packets.</t>

          <t>By increasing packet overhead, nesting may lead to fragmentation
          or decreased MTU in some networks.</t>
        </section>

        <section anchor="hybrid" title="Stateful/Metadata Hybrid">
          <t>The basic idea of this approach is for the IBN to save upper
          domain encapsulation information such that it can be retrieved by a
          unique identifier, termed an "hSFC Flow ID".</t>

          <t>The ID is placed, for example, in the NSH Fixed-Length Context
          Header of the packet in the lower domain, as shown in <xref
          target="fig_hybrid"></xref>. Likewise, hSFC Flow ID may be encoded
          as a Variable- Length Context Header when MD Type 0x2 is used.</t>

          <t>When packets exit the lower domain, the IBN uses the ID to
          retrieve the appropriate NSH encapsulation for returning the packet
          to the upper domain.</t>

          <figure anchor="fig_hybrid"
                  title="Storing hSFC Flow ID in lower-level NSH Fixed-Length Context Header">
            <artwork align="center"><![CDATA[
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Service Path Identifier              | Service Index |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      hSFC Flow ID                             |
|              Zero Padding or other fields                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
          </figure>

          <t>Advantages of this approach include: <list style="symbols">
              <t>Does not require state based on 5-tuple, so it works with SFs
              that change the IP addresses or ports of a packet such as
              NATs.</t>

              <t>Does not require all domains to have the same metadata
              scheme.</t>

              <t>Can be used to restore any upper-domain information,
              including metadata, flags and TTL, not just service path.</t>

              <t>The lower domain only requires a single item of metadata
              regardless of the number of items of metadata used in the upper
              domain.</t>

              <t>No special functionality is required to be supported by an
              SFC-aware SF, other than the usual ability to preserve metadata
              and to apply metadata to injected packets.</t>
            </list></t>

          <t>Disadvantages include those of other stateful approaches,
          including state timeout and replication mentioned in <xref
          target="section_flow_stateful"></xref>.</t>

          <t>There may be a large number of unique NSH encapsulations to be
          stored, given that the hSFC Flow ID must represent all of the bits
          in the upper-level encapsulation. This might consume a lot of memory
          or create out-of-memory situations in which IDs cannot be created or
          old IDs are discarded while still in use.</t>
        </section>
      </section>

      <section title="Gluing Levels Together">
        <t>The SPI or metadata included in a packet received by the IBN may be
        used as input to reclassification and path selection within a
        lower-level domain.</t>

        <t>In some cases the meanings of the various path IDs and metadata
        must be coordinated between domains for the sake of proper end-to-end
        SFC operation.</t>

        <t>One approach is to use well-known identifier values in metadata,
        maintained in a global registry.</t>

        <t>Another approach is to use well-known labels for chain identifiers
        or metadata, as an indirection to the actual identifiers. The actual
        identifiers can be assigned by control-plane systems. For example, a
        sub-domain classifier could have a policy, "if pathID = classA then
        chain packet to path 1234"; the higher-level controller would be
        expected to configure the concrete higher-level 'pathID' for
        'classA'.</t>
      </section>

      <section anchor="section_deSI" title="Decrementing Service Index">
        <t>Because the IBN acts as an SFC-aware SF to the higher-level domain,
        it must decrement the Service Index in the NSH headers of the
        higher-level path. This operation should be undertaken when the packet
        is first received by the IBN, before applying any of the strategies of
        <xref target="section_strategies"></xref>, immediately prior to
        classification.</t>
      </section>

      <section anchor="section_ttl" title="Managing TTL">
        <t>The NSH base header contains a TTL field <xref
        target="RFC8300"></xref>. There is a choice: <list>
            <t>a sub-domain may appear as a pure service function, which
            should not decrement the TTL from the perspective of the
            higher-level domain, or</t>

            <t>all of the TTL changes within the sub-domain may be visible to
            the higher-level domain.</t>
          </list></t>

        <t>Some readers may recognize this as a choice between "pipe" and
        "uniform" models, respectively <xref target="RFC3443"></xref>.</t>

        <t>The network operator should be given control of this behavior,
        choosing whether to expose the lower-level topology to the higher
        layer. An implementation may support per-packet policy, allowing some
        users to perform a layer-transcending trace-route, for example.</t>

        <t>The choice affects whether the methods of restoring the paths in
        <xref target="section_strategies"></xref> restore a saved version of
        TTL or propagate it with the packet. The method of <xref
        target="section_unique_paths"></xref> does not permit topology-hiding.
        The other methods of <xref target="section_flow_stateful"></xref>,
        <xref target="enco_meta"></xref>, <xref target="nest"></xref>, and
        <xref target="hybrid"></xref> have unique methods for restoring saved
        versions of TTL.</t>
      </section>
    </section>

    <section anchor="section_classifier" title="Sub-domain Classifier">
      <t>Within the sub-domain (referring to <xref
      target="fig_hierarchical_lower"></xref>), as the classifier receives
      incoming packets, the high-level encapsulation is treated according to
      one of the methods described in <xref
      target="section_strategies"></xref> to either statefully store, encode,
      or nest header information. The classifier then selects the path and
      metadata for the packet within the sub-domain.</t>

      <t>One of the goals of the hierarchical approach is to make it easy to
      have transport-flow-aware service chaining with bidirectional paths. For
      example, it is desired that for each TCP flow, the client-to-server
      packets traverse the same SF instances as the server-to-client packets,
      but in the opposite sequence. We call this bidirectional symmetry. If
      bidirectional symmetry is required, it is the responsibility of the
      control plane to be aware of symmetric paths and configure the
      classifier to chain the traffic in a symmetric manner.</t>

      <t>Another goal of the hierarchical approach is to simplify the
      mechanisms of scaling in and scaling out SFs. All of the complexities of
      load-balancing among multiple SFs can be handled within a sub-domain,
      under control of the classifier, allowing the higher-level domain to be
      oblivious to the existence of multiple SF instances.</t>

      <t>Considering the requirements of bidirectional symmetry and
      load-balancing, it is useful to have all packets entering a sub-domain
      to be received by the same classifier or a coordinated cluster of
      classifiers. There are both stateful and stateless approaches to
      ensuring bidirectional symmetry.</t>
    </section>

    <section title="Control Plane Elements">
      <t>Although SFC control protocols have not yet been standardized (2018),
      from the point of view of hierarchical service function chaining we have
      these expectations: <list style="symbols">
          <t>Each control-plane instance manages a single level of hierarchy
          of a single domain.</t>

          <t>Each control plane is agnostic about other levels of hierarchy.
          This aspect allows humans to reason about the system within a single
          domain and allows control-plane algorithms to use only domain-local
          inputs. Top-level control does not need visibility to sub-domain
          policies, nor does sub-domain control need visibility to
          higher-level policies. (Top-level control considers a sub-domain as
          though it were an SF.)</t>

          <t>Sub-domain control planes are agnostic about control planes of
          other sub-domains. This allows both humans and machines to
          manipulate sub-domain policy without considering policies of other
          domains.</t>
        </list></t>

      <t>Recall that the IBN acts as an SFC-aware SF in the higher-level
      domain (receiving SF instructions from the higher-level control plane)
      and as a classifier in the lower-level domain (receiving classification
      rules from the sub-domain control plane). In this view, it is the IBN
      that glues the layers together.</t>

      <t>The above expectations are not intended to prohibit network-wide
      control. A control hierarchy can be envisaged to distribute information
      and instructions to multiple domains and sub-domains. Control hierarchy
      is outside the scope of this document.</t>
    </section>

    <section anchor="section_other_forwarding"
             title="Extension for Adapting to NSH-Unaware Service Functions">
      <t>The hierarchical approach can be used for dividing networks into
      NSH-aware and NSH-unaware domains by converting NSH encapsulation to
      other forwarding techniques (e.g., 5-tuple-based routing with OpenFlow),
      as shown in <xref target="fig_dividing_chain_domains"></xref>.</t>

      <figure anchor="fig_dividing_chain_domains"
              title="Dividing NSH-aware and NSH-unaware domains">
        <artwork align="center"><![CDATA[
    * * * * * * * * * * * * * * * * * *
  *   NSH-aware domain                 *
  *       +-------+       +-------+    *
  *       | SF#1  |       | SF#5  |    *
  *       +-o---o-+       +-o---o-+    *
  *         ^   |           ^   |      *
  *       +-|---|-+       +-|---|-+    *
  *       | |SFF| |       | |SFF| |    *
  *       +-|---|-+       +-|---|-+    *
  *         .   |           |   .      *
  * +--+   /    |           |    \     *
 -->|CF|--'     |           |     '-------> 
  * +--+        v           |          *
  *         +---o-----------o---+      *
   .*.*.*.*.|  / |   IBN   | \  |*.*.*. 
  .         +-o--o---------o--o-+      .
  .           |  |         ^  ^        .
  .           |  +-+     +-+  |        .
  .       +---+    v     |    +---+    .
  .       |      +-o-----o-+      |    .
  .       |      |  SF#2   |      |    .
  .       |      +---------+      |    .
  .       +--+                 +--+    .
  .          |   +---------+   |       .
  .          v   |         v   |       .
  .        +-o---o-+     +-o---o-+     .
  .        | SF#3  |     | SF#4  |     .
  .        +-------+     +-------+     .
  .   NSH-unaware domain               .
   . . . . . . . . . . . . . . . . . . 

            ]]></artwork>

        <postamble>SF#1 and SF#5 are NSH-aware and SF#2, SF#3 and SF#4 are
        NSH-unaware. In the NSH-unaware domain, packets are conveyed in a
        format supported by SFs which are deployed there.</postamble>
      </figure>

      <section title="Purpose">
        <t>This approach is expected to facilitate service chaining in
        networks in which NSH-aware and NSH-unaware SFs coexist. Some examples
        of such situations are: <list style="symbols">
            <t>In a period of transition from legacy SFs to NSH-aware SFs,
            and</t>

            <t>Supporting multi-tenancy.</t>
          </list></t>
      </section>

      <section title="Requirements for IBN">
        <t>In this usage, an IBN classifier is required to have an NSH
        conversion table for applying packets to appropriate lower-level paths
        and returning packets to the correct higher-level paths. For example,
        the following methods would be used for saving/restoring upper-level
        path information: <list style="symbols">
            <t>Saving SPI and SI in transport-layer flow state (refer to <xref
            target="section_flow_stateful"></xref>) and</t>

            <t>Using unique lower-level paths per upper-level NSH coordinates
            (refer to <xref target="section_unique_paths"></xref>).</t>
          </list></t>

        <t>Especially, the use of unique paths approach would be good for
        translating NSH to a different forwarding technique in the lower
        level. A single path in the upper level may be branched to multiple
        paths in the lower level such that any lower-level path is only used
        by one upper-level path. This allows unambiguous restoration to the
        upper-level path.</t>

        <t>In addition, an IBN might be required to convert metadata contained
        in NSH to the format appropriate to the packet in the lower-level
        path. For example, some legacy SFs identify subscriber based on
        information of network topology, such as VID (VLAN ID), and IBN would
        be required to create VLAN to packets from metadata if subscriber
        identifier is conveyed as metadata in higher-level domains.</t>

        <t>Other fundamental functions required as IBN (e.g., maintaining
        metadata of upper level or decrementing Service Index) are same as
        normal usage.</t>

        <t>It is useful to permit metadata to be transferred between levels of
        a hierarchy. Metadata from a higher level may be useful within a
        sub-domain and a sub-domain may augment metadata for consumption in an
        upper domain. However, allowing uncontrolled metadata between domains
        may lead to forwarding failures. <list>
            <t>In order to prevent SFs of low-level SFC-enabled domains from
            supplying (illegitimate) metadata, IBNs may be instructed to
            permit specific metadata types to exit the sub-domain. Such
            control over the metadata in the upper level is the responsibility
            of the upper-level control plane.</t>

            <t>To limit unintentional metadata reaching SFs of low-level
            SFC-enabled sub-domains, IBNs may be instructed to permit specific
            metadata types into the sub-domain. Such control of metadata in
            the low-level domain is the responsibility of the lower-level
            control plane.</t>
          </list></t>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The concept of Hierarchical Service Path Domains was introduced in
      <xref target="I-D.homma-sfc-forwarding-methods-analysis"></xref> as a
      means to improve scalability of service chaining in large networks.</t>

      <t>The concept of nesting NSH headers within lower-level NSH was
      contributed by Ting Ao. The concept originally appeared in <xref
      target="I-D.ao-sfc-for-dc-interconnect"></xref> as a means of creating
      hierarchical SFC in a data center.</t>

      <t>We thank Dapeng Liu for contributing the data-center examples in the
      appendix.</t>

      <t>The Stateful/Metadata Hybrid section was contributed by Victor
      Wu.</t>

      <t>The authors would also like to thank the following individuals for
      providing valuable feedback:</t>

      <t><list style="hanging">
          <t>Ron Parker</t>

          <t>Christian Jacquenet</t>

          <t>Jie Cao</t>

          <t>Kyle Larose</t>
        </list></t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Hierarchical service function chaining makes use of service chaining
      architecture, and hence inherits the security considerations described
      in the architecture document <xref target="RFC7665"></xref>.</t>

      <t>Furthermore, hierarchical service function chaining inherits security
      considerations of the data-plane protocols (e.g., NSH) and control-plane
      protocols used to realize the solution.</t>

      <t>This document describes systems that may be managed by distinct teams
      of a single administrative entity. Sub-domains must have consistent
      configurations in order to properly forward traffic. Any protocol
      designed to distribute the configurations must be secure from tampering.
      Means to prevent attacks from within a network must be enforced. For
      example, continuously monitoring the network may allow detecting such
      misbehaviors. hSFC adheres to the same security considerations of <xref
      target="RFC8300"></xref>. Those considerations must be taken into
      account.</t>

      <t>All of the systems and protocols must be secure from modification by
      untrusted agents.</t>

      <section title="Control Plane">
        <t>Security considerations related to the control plane should be
        discussed in the corresponding control specification documents (e.g.,
        <xref target="I-D.ietf-bess-nsh-bgp-control-plane"></xref>, <xref
        target="I-D.wu-pce-traffic-steering-sfc"></xref>, or <xref
        target="I-D.maglione-sfc-nsh-radius"></xref>).</t>

        <t>Generic security considerations related to the control plane are
        discussed in <xref target="I-D.ietf-sfc-control-plane"></xref>. These
        considerations apply for both high-level and low-level domains.</t>
      </section>

      <!-- REVISIT: why are infinite forwarding loops required to be discussed here? -->

      <section title="Infinite Forwarding Loops">
        <t>Distributing policies among multiple domains may lead to forwarding
        loops. NSH supports the ability to detect loops (<xref
        target="section_deSI"></xref> and <xref target="section_ttl"></xref>),
        but means to ensure the consistency of the policies should be enabled
        at all levels of a domain. Within the context of hSFC, it is the
        responsibility of the Control Elements at all levels to prevent such
        (unwanted) loops.</t>
      </section>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.7665'?>

      <?rfc include='reference.RFC.8300'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.ao-sfc-for-dc-interconnect'?>

      <?rfc include='reference.I-D.homma-sfc-forwarding-methods-analysis'?>

      <?rfc include='reference.I-D.ietf-bess-nsh-bgp-control-plane'?>

      <?rfc include='reference.I-D.ietf-sfc-control-plane'?>

      <?rfc include='reference.I-D.ietf-sfc-dc-use-cases'?>

      <?rfc include='reference.I-D.maglione-sfc-nsh-radius'?>

      <?rfc include='reference.I-D.wu-pce-traffic-steering-sfc'?>

      <?rfc include='reference.RFC.3443'?>
    </references>

    <!-- Appendix -->

    <section anchor="app1"
             title="Examples of Hierarchical Service Function Chaining">
      <t>The advantage of hierarchical service function chaining compared with
      normal or flat service function chaining is that it can reduce the
      management complexity significantly. This section discusses examples
      that show those advantages.</t>

      <section title="Reducing the Number of Service Function Paths">
        <t>In this case, hierarchical service function chaining is used to
        simplify service function chaining management by reducing the number
        of SFPs.</t>

        <t>As shown in <xref target="fig_example_flat"></xref>, there are two
        domains, each with different concerns: a Security Domain that selects
        SFs based on network conditions and an Optimization Domain that
        selects SFs based on traffic protocol.</t>

        <t>In this example there are five security functions deployed in the
        Security Domain. The Security Domain operator wants to enforce the
        five different security policies, and the Optimization Domain operator
        wants to apply different optimizations (either cache or video
        optimization) to each of these two types of traffic. If we use flat
        SFC (normal branching), 10 SFPs are needed in each domain. In
        contrast, if we use hierarchical SFC, only 5 SFPs in Security Domain
        and 2 SFPs in Optimization Domain will be required, as shown in <xref
        target="fig_example_hsfc"></xref>.</t>

        <t>In the flat model, the number of SFPs is the product of the number
        of SFs in all of the domains. In the hSFC model, the number of SFPs is
        the sum of the number of SFs. For example, adding a "bypass" path in
        the Optimization Domain would cause the flat model to require 15 paths
        (5 more), but cause the hSFC model to require one more path in the
        Optimization Domain.</t>

        <figure anchor="fig_example_flat" title="Flat SFC (normal branching)">
          <artwork><![CDATA[
           . . . . . . . . . . . .   . . . . . . . . . . . . .
           . Security Domain     .   .  Optimization Domain  .
           .                     .   .                       .
           .    +-1---[     ]----------------->[Cache  ]------->
           .    |     [ WAF ]    .   .                       .
           .    +-2-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .    
           .    +-3---[Anti ]----------------->[Cache  ]------->
           .    |     [Virus]    .   .                       .
           .    +-4-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-5-->[     ]----------------->[Cache  ]------->
[DPI]--->[CF]---|     [ IPS ]    .   .                       .
           .    +-6-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-7-->[     ]----------------->[Cache  ]------->
           .    |     [ IDS ]    .   .                       .
           .    +-8-->[     ]----------------->[Video Opt.]---->
           .    |                .   .                       .
           .    +-9-->[Traffic]--------------->[Cache  ]------->
           .    |     [Monitor]  .   .                       .
           .    +-10->[       ]--------------->[Video Opt.]---->
           . . . . . . . . . . . .   . . . . . . . . . . . . .


Legend: 
   IDS: Intrusion Detection System
   IPS: Intrusion Prevention System
   WAF: Web Application Firewall
]]></artwork>

          <postamble>The classifier must select paths that determine the
          combination of Security and Optimization concerns. 1:WAF+Cache,
          2:WAF+VideoOpt, 3:AntiVirus+Cache, 4:AntiVirus+VideoOpt, 5:
          IPS+Cache, 6:IPS+VideoOpt, 7:IDS+Cache, 8:IDS+VideoOpt,
          9:TrafficMonitor+Cache, 10:TrafficMonitor+VideoOpt</postamble>
        </figure>

        <figure anchor="fig_example_hsfc"
                title="Simplified path management with Hierarchical SFC">
          <artwork><![CDATA[
     . . . . . . . . . . . . . . .    . . . . . . . . . . . . . . .
     .     Security Domain       .    .   Optimization Domain     .
     .                           .    .                           .
[CF]---->[  [CF]    IBN      ]---------->[  [CF]   IBN         ]---->
     .    |                  ^   .    .  |                     ^  .
     .    +----->[ WAF ]-----+   .    .  +-->[ Cache ]---------+  .
     .    |                  |   .    .  |                     |  .
     .    +-->[Anti-Virus]---+   .    .  +-->[Video Opt]-------+  .
     .    |                  |   .    .                           .
     .    +----->[ IPS ]-----+   .    . . . . . . . . . . . . . . .
     .    |                  |   .
     .    +----->[ IDS ]-----+   .
     .    |                  |   .
     .    +-->[ Traffic ]----+   .
     .        [ Monitor ]        .
     . . . . . . . . . . . . . . .
        ]]></artwork>
        </figure>
      </section>

      <section title="Managing a Distributed Data-Center Network">
        <t>Hierarchical service function chaining can be used to simplify
        inter-data-center SFC management. In the example of <xref
        target="fig_example_hsfc_inter_dc"></xref>, shown below, there is a
        central data center (Central DC) and multiple local data centers
        (Local DC#1, #2, #3) that are deployed in a geographically distributed
        manner. All of the data centers are under a single administrative
        domain.</t>

        <t>The central DC may have some service functions that the local DC
        needs, such that the local DC needs to chain traffic via the central
        DC. This could be because: <list style="symbols">
            <t>Some SFs are deployed as dedicated hardware appliances, and
            there is a desire to lower the cost (both CAPEX and OPEX) of
            deploying such SFs in all data centers.</t>

            <t>Some SFs are being trialed, introduced or otherwise handle a
            relatively small amount of traffic. It may be cheaper to manage
            these SFs in a single central data center and steer packets to the
            central data center than to manage these SFs in all data
            centers.</t>
          </list></t>

        <figure anchor="fig_example_hsfc_inter_dc"
                title="Simplify inter-DC SFC management">
          <artwork><![CDATA[
                +-----------+
                |Central DC |
                +-----------+
                   ^  ^   ^
                   |  |   |
               .---|--|---|----.    
              /   /   |   |      \
             /   /    |    \      \ 
  +-----+   /   /     |     \      \    +-----+
  |Local|  |   /      |      \     |    |Local|
  |DC#1 |--|--.       |       .----|----|DC#3 |
  +-----+  |          |            |    +-----+
            \         |            /
             \        |           /  
              \       |          /   
               '----------------'    
                      |      
                   +-----+
                   |Local|
                   |DC#2 |
                   +-----+                          
                    
          ]]></artwork>
        </figure>

        <t>For large data center operators, one local DC may have tens of
        thousands of servers and hundreds of thousands of virtual machines.
        SFC can be used to manage user traffic. For example, SFC can be used
        to classify user traffic based on service type, DDoS state, etc.</t>

        <t>In such large scale data center, using flat SFC is very complex,
        requiring a super-controller to configure all data centers. For
        example, any changes to SFs or SFPs in the central DC (e.g., deploying
        a new SF) would require updates to all of the SFPs in the local DCs
        accordingly. Furthermore, requirements for symmetric paths add
        additional complexity when flat SFC is used in this scenario.</t>

        <t>Conversely, if using hierarchical SFC, each data center can be
        managed independently to significantly reduce management complexity.
        SFPs between data centers can represent abstract notions without
        regard to details within data centers. Independent controllers can be
        used for the top level (getting packets to pass the correct data
        centers) and local levels (getting packets to specific SF
        instances).</t>
      </section>
    </section>
  </back>
</rfc>
